{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogger/distributed-dbscan-intuition/","result":{"data":{"site":{"siteMetadata":{"title":"Coding with Thomas"}},"markdownRemark":{"id":"1ae9f529-012b-5af9-b7a8-fba48c95514a","excerpt":"Hey all, it has been quite a long time since my last blog post. Thanks to my work, to keep me busy all day and don’t let me research on cool new things. However…","html":"<p>Hey all,</p>\n<p>it has been quite a long time since my last blog post. Thanks to my work, to keep me busy all day and don’t let me research on cool new things. However, over the few holidays and weekends over the last weeks I came across a very interesting algorithm called DBSCAN.<br>\nIt is abbreviated for ”<em>density-based spatial clustering of applications with noise</em>”, it is a unsupervised clustering algorithm just like k-means, besides that it is much smarter in many aspects.<br>\nAnother objective I’d like to solve is the parallelization of this algorithm. I’ve seen just some ancient papers and what buffels me is that I’ve seen no implementation in Mahout (for MapReduce) or other distributed frameworks.</p>\n<p>As you may know, I’m working for Apache Hama. It is a framework for distributed computing with the BSP (bulk synchronous parallel) model. I always searching for new algorithms that could fit into the model of BSP computing, e.G. graph algorithms of all sorts, strongly iterative algorithms, real-time algorithms.<br>\nAnd I think that DBSCAN also fits into the BSP model, I tell you why a bit later in this post.<br>\nFirst off, just a little introduction of the DBSCAN algorithm itself…</p>\n<p><strong>The algorithm</strong></p>\n<p>The algorithm is very easy to understand. Actually you have a bunch of points (or vectors in higher dimensionalities) as input, then you have to parameters and some fancy output.<br>\nThe two parameters are called <em>“epsilon”</em> and <em>“minpoints”,</em> epsilon is the minimum distance between two vectors to connect two points <strong>strongly</strong> and minpoints is the number of points that are at least needed to build a cluster out of strongly connected vectors.<br>\nNow you are going through the graph, point by point, marking visited vectors and adding points to a cluster while they are not violating the rules defined by epsilon and minpoints.</p>\n<p>You can read on <a href=\"http://en.wikipedia.org/wiki/DBSCAN\">wikipedia</a> about how the sequential version works in detail, however I am going to propose a much more easier to understand version of the algorithm.</p>\n<p><strong>Distributed algorithm steps</strong></p>\n<p>Instead of defining a big distributed algorithm that translates the sequential version into some distributed programming model, I have assembled three main steps to get the same result as the sequential version.<br>\nHowever each of these steps are strongly parallelizable in every major programming model (at least I know how it works in MapReduce, BSP and MPI).</p>\n<p>Here are the three steps:</p>\n<ol>\n<li>compute a distance matrix between the vectors with a given distance measurement</li>\n<li>trivial step to parallelize, can also be merged with the next point</li>\n<li>extract adjacent points via the epsilon threshold and the minpoints restriction</li>\n<li>This step creates an adjacency list/matrix representing a graph</li>\n<li>Noise is filtered at this step of the algorithm</li>\n<li>run a connected component algorithm on the resulting graph of the previous step</li>\n<li>Already done that in <a href=\"http://codingwiththomas.blogspot.de/2011/04/graph-exploration-with-hadoop-mapreduce.html\">MapReduce</a> and <a href=\"http://codingwiththomas.blogspot.de/2011/04/graph-exploration-using-apache-hama-and.html\">BSP</a>, the last BSP version will be updated shortly after Apache Hama 0.5.0 comes out.</li>\n</ol>\n<p>These three simple steps will give you the same result as a DBSCAN. Normally you can merge step 1 with step two, you can simply extract the adjacents points while computing the distances. </p>\n<p>In the end, you will receive n-connected components, every of them will represent a cluster.</p>\n<p>The delta to the points of your original input would be the noise cluster.</p>\n<p><strong>Note</strong> that the initial step is O(n²) which is obviously pretty bad and not scalable. So think about techniques like <a href=\"http://en.wikipedia.org/wiki/Locality-sensitive_hashing\">Similarity Hashing</a> to speed this step up.</p>\n<p>Pretty easy right? I think it is even more easier than the pseudocode on wikipedia.</p>\n<p>Of course I put up a <a href=\"https://github.com/thomasjungblut/thomasjungblut-common/blob/master/src/main/java/de/jungblut/clustering/DBSCAN.java\">sample version (albeit sequential) on my github repo</a>. There is also the <a href=\"https://github.com/thomasjungblut/thomasjungblut-common/blob/master/src/main/java/de/jungblut/clustering/DBSCANClustering.java\">original DBSCAN algorithm for comparison</a>.</p>\n<p>There is a nice plot I received when running it:</p>\n<p><a href=\"http://1.bp.blogspot.com/-Ee0cBBn1wr4/T6apx5kMTgI/AAAAAAAABig/UONAjcTrP2I/s1600/dbscan.JPG\"><img src=\"http://1.bp.blogspot.com/-Ee0cBBn1wr4/T6apx5kMTgI/AAAAAAAABig/UONAjcTrP2I/s320/dbscan.JPG\" alt=\"\"></a></p>\n<p>To make the noise more easy to spot, I have made horrible yellow circles arround them with Paint, please forgive me ;)</p>\n<p>So far I haven’t found the time to implement this whole system with Apache Hama. <a href=\"http://stackoverflow.com/questions/15863566/need-assistance-with-implementing-dbscan-on-map-reduce/15863699#15863699\">However, if you want to practically use this here are some advices</a>:</p>\n<ul>\n<li>For the distance matrix to compute, better use a heuristic to find close vectors</li>\n<li>Mahout has a MinHashing implementation of such a clustering</li>\n<li>Once you obtained “mini” clusters, you can compute more expensive distance measurements and extract your graph (step two in the above list)</li>\n</ul>","frontmatter":{"title":"Distributed DBSCAN (Intuition)","date":"6th May 2012","description":null},"tableOfContents":"","timeToRead":3},"previous":{"fields":{"slug":"/blogger/nonlinear-conjugate-gradient-method-in/"},"frontmatter":{"title":"Nonlinear conjugate gradient method in Java"}},"next":{"fields":{"slug":"/blogger/set-expansion-by-iterative-similarity/"},"frontmatter":{"title":"Set Expansion by Iterative Similarity Aggregation"}}},"pageContext":{"id":"1ae9f529-012b-5af9-b7a8-fba48c95514a","previousPostId":"684f5398-15bf-5c0a-b0ff-c0e05a82e5a3","nextPostId":"ba50c37f-540d-518d-bea5-44200931e252"}},"staticQueryHashes":["2270107033","2841359383"],"slicesMap":{}}