{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogger/ant-colony-optimization-for-tsp/","result":{"data":{"site":{"siteMetadata":{"title":"Coding with Thomas"}},"markdownRemark":{"id":"76b5ebc4-91c3-5d4f-957c-9fd72740c5d6","excerpt":"Code can be found on (Github) Hi there, I recently focused on playing around with ant colony AI (artificial intelligence) methods, as part of my second semester…","html":"<p>Code can be found on (<a href=\"https://github.com/thomasjungblut/antcolonyopt\">Github</a>)</p>\n<p>Hi there,</p>\n<p>I recently focused on playing around with ant colony AI (artificial intelligence) methods, as part of my second semester undergraduation project in Software Engineering.</p>\n<p>Wikipedia’s definition for Ant Colony Optimization is the following:</p>\n<blockquote>\n<p>In computer science and operations research, the <strong>ant colony optimization</strong> algorithm <strong>(ACO)</strong> is a probabilistic technique for solving computational problems which can be reduced to finding good paths through graphs.</p>\n</blockquote>\n<p>Unlike previous posts, it is a multithreaded solution which runs best on a single machine and not in a cluster and this post is about TSP (<a href=\"http://en.wikipedia.org/wiki/Travelling_salesman_problem\">Traveling Salesman Problem</a>) and not about finding shortest paths in a graph.</p>\n<p><strong>The Input</strong></p>\n<p>At first, we have to decide which input we take. In my case, this task was a university assignment so I have to use the given one. It is the Berlin52 problem which should be solved with the less costly route along the 52 best known / famous places in Berlin.<br>\nYou can download an euclidian 2D coordinate version of it <a href=\"http://www2.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/tsp/\">here</a>. Just look for the “berlin52.tsp.gz” file. There is also an already calculated optimal solution <a href=\"http://www2.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/tsp/berlin52.opt.tour.gz\">here</a>.</p>\n<p>Plotting the file is going to show a cool roundtrip:</p>\n<p><a href=\"http://1.bp.blogspot.com/-G_IM3Kbxwmk/Tl9GqfNfJZI/AAAAAAAAATc/erg6Iwpzu1w/s1600/tsp.png\"><img src=\"http://1.bp.blogspot.com/-G_IM3Kbxwmk/Tl9GqfNfJZI/AAAAAAAAATc/erg6Iwpzu1w/s400/tsp.png\" alt=\"\"></a></p>\n<p>The file content looks quite like this:</p>\n<blockquote>\n<p>1 565.0 575.0<br>\n2 25.0 185.0<br>\n3 345.0 750.0<br>\n4 945.0 685.0</p>\n</blockquote>\n<p>On the leftmost side is the ID of the vertex, in the middle is the x-coordinate and on the rightmost side is the y-coordinate in the euclidian plane.</p>\n<p><strong>The Algorithm</strong></p>\n<p>This algorithm is a mimicry of the real-life behaviour of ants. As you might know, Ants are quite smart in finding their way between their colony and their food source. A lot of workers are walking through the proximate environment and if they find some food, they leave a pheromone trail.<br>\nSome of the other ants are still searching for other paths, but the most of them are following the pheromone trail- making this path even more attractive. But over time the pherome trail is starting to decay / evaporate, so it is losing its attractiveness. Due to the time component, a long way has a very low density of the pheromone, because the pherome trail along the longer path is evaporating faster. Thus a very short path has a higher density of pheromones and is more attractive to the workers converging onto an approximately optimal path for our TSP problem.</p>\n<p>For the problem, we are dropping ants on random vertices in our graph. Each ant is going to evaluate the next best destination vertex based on this following formula:</p>\n<p><a href=\"http://upload.wikimedia.org/math/e/1/3/e1320f5f72b21e5766dfa7e29b536883.png\"><img src=\"http://upload.wikimedia.org/math/e/1/3/e1320f5f72b21e5766dfa7e29b536883.png\" alt=\"\"></a></p>\n<p>It is about the probabiliy “p” for an ant called “k” to move to the vertex described by “x” and “y”.<br>\nThe variable “Tau” is the amount of pheromone deposited on the edge between “xy”. It gets raised by “alpha” which is a heuristic parameter describing how greedy the algorithm is in finding its path across the graph. This is going to be multiplied by our apriori knowledge of how “good” the edge is. In our case this is the inverted distance (1 / distance) between x and y. This gets raised by “beta” which is also a heuristic parameter, which describes how fast the ants are going to converge to a steady solution. To get a transition probability to a vertex, each gets divided by the sum of the numerator over all possible left destination vertices.</p>\n<p>The next equation is about adjusting the pheromone matrix, which is described by the following formula:</p>\n<p><a href=\"http://upload.wikimedia.org/math/1/7/b/17b189b13928502c7a2e5fd7fbdc6184.png\"><img src=\"http://upload.wikimedia.org/math/1/7/b/17b189b13928502c7a2e5fd7fbdc6184.png\" alt=\"\"></a></p>\n<p>“Tau” is the amount of absolute pheromone which gets deposited for worker “k” on the “xy” edge. “Rho” is a factor between 0-1 which represents the decay of the pheromone. This gets multiplied by the current amount of pheromone deposited and we just add updated new pheromone to it (which is the delta “Tau”). Delta “Tau” is an equatation too:</p>\n<p><a href=\"http://upload.wikimedia.org/math/6/d/b/6db065218c956a4a7af6da99aaeca5d1.png\"><img src=\"http://upload.wikimedia.org/math/6/d/b/6db065218c956a4a7af6da99aaeca5d1.png\" alt=\"\"></a></p>\n<p>Wikipedia.org</p>\n<p>It is just “Q” by the accumulated distance of the path so far.</p>\n<p>Finish! That is all we need to start the implementation!</p>\n<p>The whole thing works like this:</p>\n<ol>\n<li>Initialize the best distance to infinity</li>\n<li>Choose a random vertex in the graph where to plant your ant</li>\n<li>Let the ant work their best paths using the formulas from above</li>\n<li>Let the ant update the pheromones on our graph</li>\n<li>If the worker returned with a new best distance update our currently best distance</li>\n<li>Start from 2. until we found our best path or we have reached our maximum amount of workers.</li>\n<li>Output the best distance</li>\n</ol>\n<p>The single worker will now return with a path which he has taken and with a corresponding distance. Now you can decide if you are confident with the result, or going to let the worker calculate more of them.</p>\n<p>So let’s see how we can multithread this.</p>\n<p><strong>How to Multithread</strong></p>\n<p>In this case, multithreading is very easy. Each worker unit (in my repository called “Agent”) is a single thread. In Java we have a cool thread pool construct called <em>ExecutorService</em> and a completion service which tells us when workers finished.</p>\n<p>We are submitting a few workers for to the pool, they work on the same resources and once completed we get a reponse of the completion service.</p>\n<p>Woot? Shared resources? Yes we need some sort of synchronization. In our case when writing to the pheromone matrix. In my latest implementation I used lock-free updates using Guava’s AtomicDouble.</p>\n<p>The whole algorithm is not going to change, we are just working in parallel.</p>\n<p><strong>The Result</strong></p>\n<p>After a lot of parameter testing you can find a very good solution:</p>\n<p><a href=\"http://4.bp.blogspot.com/-EOFi4Zc7xUk/Tl0drCu-6iI/AAAAAAAAATY/sMfSaPsWb8o/s1600/ant.png\"><img src=\"http://4.bp.blogspot.com/-EOFi4Zc7xUk/Tl0drCu-6iI/AAAAAAAAATY/sMfSaPsWb8o/s1600/ant.png\" alt=\"\"></a></p>\n<p>Console output of my algorithm, finding a very close solution to the optimal distance for Berlin52</p>\n<p><strong>Parameter Testing</strong></p>\n<p>Because there are a hell lot of parameters (5) in there, we have to write an testing utility which calculates the best parameters for our problem (aka GridSearch).</p>\n<p>We only care about the distance to the optimal solution:<br>\nIn the grid search we only want to keep the lowest possible mean distance to the optimal solution (measured over multiple repetitions) and a very low variance.</p>\n<p>For Berlin52, the best parameters using 200k agents I found are:</p>\n<p>Alpha = 0.1<br>\nBeta = 9<br>\nQ = 1e-4<br>\nP = 0.8</p>\n<p>So feel free to check out the code in the repository and let it run.<br>\nAnd please feel free to use this as a hint for your own implementation, or even improve it via a pull request.</p>\n<p>Thanks for your interest and have fun :-)<br>\nBye!</p>\n<p>Here’s the link to the repository again: <a href=\"https://github.com/thomasjungblut/antcolonyopt\">https://github.com/thomasjungblut/antcolonyopt</a></p>","frontmatter":{"title":"Ant Colony Optimization for TSP Problems","date":"30th August 2011","description":null},"tableOfContents":"","timeToRead":4},"previous":{"fields":{"slug":"/blogger/apache-hama-partitioning-improved/"},"frontmatter":{"title":"Apache Hama Partitioning Improved"}},"next":{"fields":{"slug":"/blogger/apache-hama-upcoming-features/"},"frontmatter":{"title":"Apache Hama upcoming features"}}},"pageContext":{"id":"76b5ebc4-91c3-5d4f-957c-9fd72740c5d6","previousPostId":"50665042-9183-58b2-838c-152c69195999","nextPostId":"c2335e32-9e7b-5c2a-9c9a-d74b7afda9d4"}},"staticQueryHashes":["2270107033","2841359383"],"slicesMap":{}}