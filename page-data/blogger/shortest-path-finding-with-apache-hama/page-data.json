{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogger/shortest-path-finding-with-apache-hama/","result":{"data":{"site":{"siteMetadata":{"title":"Coding with Thomas"}},"markdownRemark":{"id":"b7e49558-e990-5a85-8ea4-7d083ab16a3c","excerpt":"Hi guys, I’ve finished my Google Summer of Code task. Really! Remember today is the 7th of may. And the actualy coding period goes until mid September. Okay…","html":"<p>Hi guys,</p>\n<p>I’ve finished my Google Summer of Code task. Really! Remember today is the 7th of may. And the actualy coding period goes until mid September.</p>\n<p>Okay obviously I’ve just finished the task itself, developing a new example with BSP. Since Hama does not require HBase anymore I have decided to split the tasks.<br>\nOne example (which I have submitted) is a straight single source shortest path implementation described in Google Pregel’s paper.<br>\nThe second one will be a HBase version using Dijkstra and its extend A*. The second won’t be committed to the codebase of Hama, just because I don’t want to add the old HBase dependency once again.</p>\n<p>So in the end everyone won: I used HBase to get more familiar with BigTable, Hama has a shortest path example and I can code the whole summer long knowing that I’ve finished my task ;D</p>\n<p>Okay ‘nuff talked, let’s dive into the algorithm!</p>\n<p>Like in <a href=\"http://codingwiththomas.blogspot.com/2011/04/pagerank-with-apache-hama.html\">PageRank</a> you should be familiar withthe idea behind the partitioning, read the Pregel paper and this time you should be familiar with (single source) shortest path finding.</p>\n<p><strong>Short summary of the algorithm</strong></p>\n<p>First off I just briefly describe how it should work, and then how I solved it.</p>\n<ul>\n<li>Initialize all vertices’ cost to reach it to INFINITY, just the start vertex will have cost 0</li>\n<li>initially send the new cost to all adjacent vertex containing the new cost plus the edge weight between them</li>\n<li>Reviewing messages: if the cost coming from a message is lower than the actual cost, update the cost and send a message to the adjacent vertices, containing the new cost plus the edge weight between them (similar to the last step)</li>\n<li>Repeat the last step until no updates can be made anymore.</li>\n</ul>\n<p>That is pretty much it.</p>\n<p><strong>How we do it!</strong></p>\n<p>First we need a model class that represents a shortest path vertex. It has a name/ID, a weight and a cost. The cost is the cost with the vertex can be reached from our starting vertex.<br>\nA vertex will have an ID, that is just the hashcode of the name. I wanted a common way to partition a vertex so I’ve just set this based on the name called it ID. Watch out, when adding e.G. cities with the same name.</p>\n<p>I will skip the whole partitioning step, you can read the other posts to learn more about it, shortly described it is just a modulo function that will spread the vertices to different sequencefiles. These sequencefiles will get read during job initilization and mapped into memory.</p>\n<p>So let’s step into the code…</p>\n<p><strong>Fields we need</strong></p>\n<p>Because we store this time the cost and weights into a modelling vertex we just need a adjacency list and a lookup map.<br>\nThis looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> adjacencyList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">></span></span> vertexLookupMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </code></pre></div>\n<p>Basically we are storing a vertex to its adjacents and the name to the vertex itself. I’ll tell you later why we need a lookup map.</p>\n<p><strong>Initialization</strong></p>\n<p>In the init phase we need to map our adjacency list into ram, get our start vertex (just create it, we need it for equality check in the following loop which will just check the name)<br>\nThe following loop will just init the costs and send it to the adjacents.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>  \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">bsp</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BSPPeerProtocol</span> peer<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">KeeperException</span><span class=\"token punctuation\">,</span>  \n      <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token comment\">// map our input into ram  </span>\n    <span class=\"token function\">mapAdjacencyList</span><span class=\"token punctuation\">(</span>conf<span class=\"token punctuation\">,</span> peer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\">// get the start vertex  </span>\n    <span class=\"token class-name\">ShortestPathVertex</span> start <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>  \n        conf<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"shortest.paths.start.vertex.id\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\">// get our master groom  </span>\n    <span class=\"token class-name\">String</span> master <span class=\"token operator\">=</span> conf<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">MASTER_TASK</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\">// init the vertices  </span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ShortestPathVertex</span> v <span class=\"token operator\">:</span> adjacencyList<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        v<span class=\"token punctuation\">.</span><span class=\"token function\">setCost</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token comment\">// INF  </span>\n        v<span class=\"token punctuation\">.</span><span class=\"token function\">setCost</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token punctuation\">}</span>  \n      <span class=\"token comment\">// initial message bypass  </span>\n      <span class=\"token function\">sendMessageToNeighbors</span><span class=\"token punctuation\">(</span>peer<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n  \n</code></pre></div>\n<p><strong>The send method</strong></p>\n<p>The send method takes advantage of the partitioning, to get the target groom where the vertex is actually stored.<br>\nIt will bascially send a message containing the name of the vertex it targets and the cost it can be reached through the vertex in the parameter line.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sendMessageToNeighbors</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BSPPeerProtocol</span> peer<span class=\"token punctuation\">,</span>  \n      <span class=\"token class-name\">ShortestPathVertex</span> id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">{</span>  \n  \n    <span class=\"token class-name\">List</span> outgoingEdges <span class=\"token operator\">=</span> adjacencyList<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ShortestPathVertex</span> adjacent <span class=\"token operator\">:</span> outgoingEdges<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>adjacent<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> peer<span class=\"token punctuation\">.</span><span class=\"token function\">getAllPeerNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n      peer<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>peer<span class=\"token punctuation\">.</span><span class=\"token function\">getAllPeerNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>mod<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>  \n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">IntegerMessage</span><span class=\"token punctuation\">(</span>adjacent<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>  \n              id<span class=\"token punctuation\">.</span><span class=\"token function\">getCost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span> <span class=\"token operator\">?</span> id<span class=\"token punctuation\">.</span><span class=\"token function\">getCost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> id<span class=\"token punctuation\">.</span><span class=\"token function\">getCost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  \n                  <span class=\"token operator\">+</span> adjacent<span class=\"token punctuation\">.</span><span class=\"token function\">getWeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Main Loop</strong></p>\n<p>Very simple is the main loop, it is a while(true) loop that will break if no updates can be made anymore.<br>\nSo we are just parsing incoming messages, comparing the cost with the current cost. If the new cost is lower, then update it, put it into a queue and increment a local update counter.</p>\n<p>Now we need the lookup map, to get fast access to the actual cost in the vertex.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> updated <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>updated<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      <span class=\"token keyword\">int</span> updatesMade <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  \n      peer<span class=\"token punctuation\">.</span><span class=\"token function\">sync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  \n      <span class=\"token class-name\">IntegerMessage</span> msg <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token class-name\">Deque</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">></span></span> updatedQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ShortestPathVertex</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>msg <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IntegerMessage</span><span class=\"token punctuation\">)</span> peer<span class=\"token punctuation\">.</span><span class=\"token function\">getCurrentMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token class-name\">ShortestPathVertex</span> vertex <span class=\"token operator\">=</span> vertexLookupMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">getTag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token comment\">// check if we need an distance update  </span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">.</span><span class=\"token function\">getCost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> msg<span class=\"token punctuation\">.</span><span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n          updatesMade<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>  \n          updatedQueue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n          vertex<span class=\"token punctuation\">.</span><span class=\"token function\">setCost</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n      <span class=\"token punctuation\">}</span>  \n      <span class=\"token comment\">// synchonize with all grooms if there were updates  </span>\n      updated <span class=\"token operator\">=</span> <span class=\"token function\">broadcastUpdatesMade</span><span class=\"token punctuation\">(</span>peer<span class=\"token punctuation\">,</span> master<span class=\"token punctuation\">,</span> updatesMade<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token comment\">// send updates to the adjacents of the updated vertices  </span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ShortestPathVertex</span> vertex <span class=\"token operator\">:</span> updatedQueue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token function\">sendMessageToNeighbors</span><span class=\"token punctuation\">(</span>peer<span class=\"token punctuation\">,</span> vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span>  \n  \n</code></pre></div>\n<p>Afterwards we are sending the updatecounter to a master groom that will evaluate and check if updates can be applied. I leave this method out, you can check out the pagerank error method. It is roughly the same.</p>\n<p>If we have updates to apply, we just send them to the neighbor edges again.<br>\nThen we are just repeating until the master says: no updates can occur anymore.</p>\n<p><strong>Submit your own SequenceFile adjacency list</strong></p>\n<p>This is of course an example, so you can submit this to your own cluster and give it the input you like. I have designed the input like this:</p>\n<blockquote>\n<p>The adjacencylist contains two text fields on each line. The key<br>\ncomponent is the name of a vertex, the value is a ”:” separated Text<br>\nfield that contains the name of the adjacent vertex leftmost and the<br>\nweight on the rightmost side.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">K            /                V   \nVertex[Text] / AdjacentVertex : Weight [Text]</code></pre></div>\n</blockquote>\n<p>So you can setup a sequencefile like this (obviously I won’t write any binary code here :p ):</p>\n<blockquote>\n<p>Berlin /  Paris : 25<br>\nBerlin / London : 40<br>\nLondon / Paris : 10<br>\netc.</p>\n</blockquote>\n<p>The basic usage of the command line arguments are:</p>\n<blockquote>\n<p><name of the start vertex> &#x3C;optional: output path> &#x3C;optional: path of your own sequencefile></p>\n</blockquote>\n<p>So you can run this with:</p>\n<blockquote>\n<p>hama/bin/hama jar ../hama-0.x.0-examples.jar sssp Berlin /srv/tmp/ /home/user/myOwnGraph.seq</p>\n</blockquote>\n<p>I’ve submitted this as a patch here: <a href=\"https://issues.apache.org/jira/browse/HAMA-359\">https://issues.apache.org/jira/browse/HAMA-359</a><br>\nSo feel free to check it out, I hope it will get comitted soon. Never the less, it is contained also in my trunk on google code: <a href=\"http://code.google.com/p/hama-shortest-paths/\">http://code.google.com/p/hama-shortest-paths/</a><br>\nClass is called: <strong>de.jungblut.hama.bsp.ShortestPaths</strong><br>\nJust run the main method ;)</p>\n<p>Have fun with it!</p>","frontmatter":{"title":"Shortest Path Finding with Apache Hama","date":"7th May 2011","description":null},"tableOfContents":"","timeToRead":5},"previous":{"fields":{"slug":"/blogger/google-summer-of-code/"},"frontmatter":{"title":"Google Summer of Code"}},"next":{"fields":{"slug":"/blogger/series-k-means-clustering-mapreduce-bsp/"},"frontmatter":{"title":"Series: K-Means Clustering (MapReduce | BSP)"}}},"pageContext":{"id":"b7e49558-e990-5a85-8ea4-7d083ab16a3c","previousPostId":"32875d1c-96d6-50c5-9efa-04374a9ff7ad","nextPostId":"9bb0e9d1-863b-5384-a5d9-a104dd15a5b3"}},"staticQueryHashes":["2270107033","2841359383"],"slicesMap":{}}