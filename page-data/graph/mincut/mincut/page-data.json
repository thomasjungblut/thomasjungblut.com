{"componentChunkName":"component---src-templates-blog-post-js","path":"/graph/mincut/mincut/","result":{"data":{"site":{"siteMetadata":{"title":"Coding with Thomas"}},"markdownRemark":{"id":"f2920e83-517d-5f8d-8b3a-b66adb1c3a78","excerpt":"Welcome back to my first actual blogging topic of 2020, yes - I’m late and even though I have a huge backlog of video games waiting for me, I’m still spending…","html":"<p>Welcome back to my first actual blogging topic of 2020, yes - I’m late and even though I have a huge backlog of video games waiting for me, I’m still spending some time to write this post because I struggled a lot to find good resources for this algorithm.</p>\n<p>Today is about computing the <a href=\"https://en.wikipedia.org/wiki/Minimum_cut\">Minimum Cut</a> of a graph using the <a href=\"https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm\">Stoer–Wagner algorithm</a>. I largely follow the <a href=\"https://refubium.fu-berlin.de/bitstream/handle/fub188/18688/1994_12.pdf?sequence=1&#x26;isAllowed=y\">original paper published by Mechthild Stoer and Frank Wagner</a> and add fancy looking pictures and explain it along with some Java code.</p>\n<p>A full implementation of the <a href=\"https://github.com/thomasjungblut/tjungblut-graph/blob/master/src/de/jungblut/graph/partition/StoerWagnerMinCut.java\">Stoer-Wagner algorithm</a> can be found in my <a href=\"https://github.com/thomasjungblut/tjungblut-graph\">graph library</a>.</p>\n<h2 id=\"what-are-minimum-cuts\" style=\"position:relative;\"><a href=\"#what-are-minimum-cuts\" aria-label=\"what are minimum cuts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What are Minimum Cuts?</h2>\n<p>A Minimum Cut is a a way to partition a (weighted) graph into two disjoint graphs (a “cut”) so that the edges connecting these two graphs are of minimal weight in summation.</p>\n<p>According to the official definition in the paper, a Mincut is:</p>\n<blockquote>\n<p>… a nontrivial partition of the graph’s vertex set V into two parts such that the sum of the weights of the edges connecting the two parts is minimum</p>\n</blockquote>\n<p>An example mincut of the graph mentioned in the paper can be seen here:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d452bc780c6cfd20d8a0204ae813c380/57dc1/mincut_result.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACFklEQVR42k2S30tTYRjHz98SESRdFXVloP2Awrt+XNZVlCRJ9mOoIYXECC/EG0EwKFTKZqZNQlEk00nTGrmTuuPc3C+dO9s5m8xjm2c7+7Tz2kUPfPm+74eHh/f98kj+HQ/rqWVKlkmlUqkKonqAn/FZsgdp7CpbZeGlgoGxOsfBhherZB6xwyKGsoix9o1S8Q9Sk6ue+646Xns6SYR3mZLf0Tx6keaRy7S5r6NF/RSDYcxYlEzvbbS2U+htNSSHWglsJUgPPUVvrSFT5Zn+u0gtn65g6/1yDwd7h7i9gzwabeDxWAPO6TtkEwHYVbGSSbIDLWgvzpLpOEN6vItUziD0xkG64zTa83Pow+1Inl+zKLEV8fxwOMyGsklMDTHz3Y1pFQS3oxBe/frq/BdykVVxX1sPEInGyG79Zm1h0u5A8gd8bKsxdhJJZFkWjWl9l6UVz3/DjgbaJS8vktdShKJxFEURLJvaxr+0IM5S+8QNkdXAXDeHRhlfZI7OyVuC9c47yKtR0LNYuk5uzInmrEd9Wcemq4u9Qhl9pp+M84JQ7vMrpMbh89z7UEvfwjPCgTgfvX00ump5MHKpmu1V1I0lSoEg5maQdPc1NMcJ9CfHSL19iByMsNPfhO44jtZ6ErXnJpI3MoUv/pViqSBWxqpYKKqP+dA4aj7xb20s4eZ+jvwPN/vyjFgROwjb9/3TVT6BaezxF6mzFzcGhR6VAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mincut-example\"\n        title=\"\"\n        src=\"/static/d452bc780c6cfd20d8a0204ae813c380/f058b/mincut_result.png\"\n        srcset=\"/static/d452bc780c6cfd20d8a0204ae813c380/c26ae/mincut_result.png 158w,\n/static/d452bc780c6cfd20d8a0204ae813c380/6bdcf/mincut_result.png 315w,\n/static/d452bc780c6cfd20d8a0204ae813c380/f058b/mincut_result.png 630w,\n/static/d452bc780c6cfd20d8a0204ae813c380/57dc1/mincut_result.png 718w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>You see the two disjoint subgraphs, green on the left and orange on the right. The edges in red are the edges “on the cut”, meaning those are the ones that separate the two subgraphs. This graph has the mincut weight of 4, since the sum of the edge weights on the cut is exactly that (3+1).</p>\n<h2 id=\"what-are-some-real-life-applications-for-it\" style=\"position:relative;\"><a href=\"#what-are-some-real-life-applications-for-it\" aria-label=\"what are some real life applications for it permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What are some real-life applications for it?</h2>\n<p>The paper gives a nice introduction to it:</p>\n<blockquote>\n<p>Graph connectivity is one of the classical subjects in graph theory, and has many practical applications, e.g. in chip and circuit design, reliability of communication networks, transportation planning and cluster analysis.</p>\n</blockquote>\n<p>Before deep learning became good at it, it was used in image segmentation along with spectral clustering and it’s being used in detecting bottlenecks in any kind of flow networks.</p>\n<p>As a real-life example, think of a transportation network that connects two cities and they are only connected via two fairly narrow roads - like our example graph above. A min-cut could partition the (transportation) graph into the two disjoint subsets (cities) and detect the narrow roads as the edges that separate them according to some weighting schema (eg. the narrowness of the road or the speed limit on such a road).</p>\n<h2 id=\"the-intuition-of-the-algorithm\" style=\"position:relative;\"><a href=\"#the-intuition-of-the-algorithm\" aria-label=\"the intuition of the algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The intuition of the algorithm</h2>\n<p>We’ll dive into the exact algorithm below, but I wanted to give a bit of insight on how this algorithm works. The crucial observation that is behind the algorithm is very similar to <a href=\"https://en.wikipedia.org/wiki/Prim%27s_algorithm\">Prims algorithm</a>, which is finding the Minimum Spanning Tree (MST).  Prim works by starting at any vertex, always adding the next minimal edge in the graph until all vertices are connected.</p>\n<p>Stoer-Wagner is basically the same in reverse: we’re taking the full graph and starting at any vertex and doing a <code class=\"language-text\">maximum adjacency search</code> which results in finding two vertices <code class=\"language-text\">s</code> and <code class=\"language-text\">t</code>. Those are the last two vertices we found during the search - don’t worry we’ll explain the search in detail below.<br>\n<code class=\"language-text\">s</code> and <code class=\"language-text\">t</code> are then merged into one vertex, effectively <code class=\"language-text\">t</code> will be removed from the graph and its edges will then transfer to <code class=\"language-text\">s</code> (summing the weights in case both pointed to the same vertex). <code class=\"language-text\">t</code> is kept as part of our first partition and we keep track of the <code class=\"language-text\">cut weight</code> of <code class=\"language-text\">t</code>.</p>\n<p>Now doing this dance recursively, we find ourself growing our partition (all the <code class=\"language-text\">t</code>’s gathered so far) and a shrinking graph (as we’re constantly removing <code class=\"language-text\">t</code>’s). Inevitably we end up with a graph that only has two vertices, which we are merging into one and this is where we stop the algorithm. While we’re doing this, we keep track of the partitions that had the smallest <code class=\"language-text\">cut weight</code> so far. This smallest <code class=\"language-text\">cut weight</code> set of <code class=\"language-text\">t</code>’s at the end is our first partition and the remainder of the vertices in that graph is our second partition.</p>\n<p>Voilá, you cut the graph in half with minimal weights between.</p>\n<h2 id=\"the-formal-algorithm\" style=\"position:relative;\"><a href=\"#the-formal-algorithm\" aria-label=\"the formal algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The formal algorithm</h2>\n<p>Formally the paper defines a <code class=\"language-text\">MinimumCutPhase</code> and a function <code class=\"language-text\">MinimumCut</code> that makes use of the former.</p>\n<p>The <code class=\"language-text\">MinimumCutPhase</code> (aka “Maximum Adjacency Search”) looks like this in pseudo code, given a Graph <code class=\"language-text\">G</code> and a starting node <code class=\"language-text\">a</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MinimumCutPhase(G, a):\n  A &lt;- {a}\n  while A != V:\n    add to A the most tightly connected vertex\n  return s, t, and the cut weight as the \"cut of the phase\"</code></pre></div>\n<p>As described earlier, we’re constantly adding the vertices to the set that are the most <code class=\"language-text\">tightly connected</code> (our <code class=\"language-text\">s</code> and <code class=\"language-text\">t</code>, found by <code class=\"language-text\">Maximum Adjacency Search</code>).</p>\n<p>Then to wrap it up, we define <code class=\"language-text\">MinimumCut</code> of the Graph <code class=\"language-text\">G</code> as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MinimumCut(G):\n  minimum cut = nil\n  while |V| > 1:\n    choose any a from V\n    cut of the phase = MinimumCutPhase(G, a)\n    if the \"cut of the phase\" cut is lighter than the current minimum cut:\n      minimum cut = cut of the phase\n    shrink G by merging the two vertices from the \"cut of the phase\" (s, t)\n  return the minimum cut</code></pre></div>\n<p>Each <code class=\"language-text\">MinimumCutPhase</code> will shrink our graph and stores the best cuts we have seen so far, always merging <code class=\"language-text\">s</code> and <code class=\"language-text\">t</code> from our <code class=\"language-text\">cut of the phase</code> as we go along. This works on graphs with positive weights and always needs at least connected two vertices, otherwise we couldn’t partition it into two.</p>\n<p>Note: the definitions are simplified and hopefully a bit clearer compared to the ones found in the paper.</p>\n<h2 id=\"maximum-adjacency-search\" style=\"position:relative;\"><a href=\"#maximum-adjacency-search\" aria-label=\"maximum adjacency search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Maximum Adjacency Search</h2>\n<p>Now as we figured, the most central part of the algorithm is the <code class=\"language-text\">Maximum Adjacency Search</code>. Despite it being described in literature with different names all the time, there is a <a href=\"https://www.boost.org/doc/libs/1_66_0/libs/graph/doc/maximum_adjacency_search.html\">good C++ implementation with academic references in Boost</a>.</p>\n<p>The intuition is that we want to traverse the graph in order of its maximum weight towards the set of vertices we have found so far - let’s call it the <code class=\"language-text\">foundSet</code>. The <code class=\"language-text\">foundSet</code> at the beginning is initialized with any vertex in that graph. In the remainder of the graph we proceed to search for the next vertex, which has the largest sum of weights towards the <code class=\"language-text\">foundSet</code>.</p>\n<p>This vertex is then removed from the graph and added to the <code class=\"language-text\">foundSet</code>. This goes on until there are no more vertices in that graph to search. The order in which the vertices are added in that <code class=\"language-text\">foundSet</code> is important, as the last two vertices are our <code class=\"language-text\">s</code> and <code class=\"language-text\">t</code> and the last sum will be the <code class=\"language-text\">cut weight</code> of the respective <code class=\"language-text\">cut of the phase</code>.</p>\n<p>Let’s dive into some code to clarify, given a simple graph interface that gives us the following methods:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Graph</span> <span class=\"token punctuation\">{</span>   \n    <span class=\"token comment\">// the unique identifiers of the vertices in that graph</span>\n    <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getVertexIDSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// returns the edge between a source vertex ID and a destination ID.</span>\n    <span class=\"token comment\">// Edge includes the weights, returns null if there is no edge</span>\n    <span class=\"token class-name\">Edge</span> <span class=\"token function\">getEdge</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> source<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> destination<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// used later, but just a nicer way to put 'getVertexIDSet().size()'</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">getNumVertices</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>The algorithm in Java looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">CutOfThePhase</span> <span class=\"token function\">maximumAdjacencySearch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Graph</span> g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> start <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">getVertexIDSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> foundSet <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">singletonList</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> cutWeight <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> candidates <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">.</span><span class=\"token function\">getVertexIDSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    candidates<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>candidates<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> maxNextVertex <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> maxWeight <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MIN_VALUE</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> next <span class=\"token operator\">:</span> candidates<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> weightSum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s <span class=\"token operator\">:</span> foundSet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token class-name\">Edge</span> edge <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">getEdge</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>edge <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    weightSum <span class=\"token operator\">+=</span> edge<span class=\"token punctuation\">.</span><span class=\"token function\">getWeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>weightSum <span class=\"token operator\">></span> maxWeight<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                maxNextVertex <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n                maxWeight <span class=\"token operator\">=</span> weightSum<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        candidates<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>maxNextVertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        foundSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>maxNextVertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cutWeight<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>maxWeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// we take the last two vertices in foundSet and their weight as a cut of the phase</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> foundSet<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CutOfThePhase</span><span class=\"token punctuation\">(</span>\n            <span class=\"token comment\">// that's \"s\" in the literature and will remain as a merged vertex with \"t\"</span>\n            foundSet<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n            <span class=\"token comment\">// that's \"t\" and will be removed afterwards</span>\n            foundSet<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n            <span class=\"token comment\">// that's \"w\" to compute the minimum cut on later</span>\n            cutWeight<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>cutWeight<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>If you read it, you may find it very similar to Depth-First-Search (DFS) - but instead of taking any vertex as the next step, we find the one that has the largest incoming edge weights to our already traversed vertices. This also reminds of Prims algorithm again, which greedily picks the next edge to construct the MST.</p>\n<blockquote>\n<p>⚠️ Premature Optimization Warning</p>\n</blockquote>\n<p>In Java you might want to optimize this O(n^2) search loop with a <code class=\"language-text\">java.util.PriorityQueue</code> and I’ve seen several implementation on the internet doing it. While correct and possible, in reality this requires you to remove and add the element again (which is a linear search to remove and a heap addition, so O(n) + O(log n) = O(n)), which is considerably slower than just a traditional <code class=\"language-text\">down-heap</code> operation and even slower than a linear search. Please use a specifically constructed Heap that implements this behaviour - for example <a href=\"https://github.com/apache/hadoop/blob/a55d6bba71c81c1c4e9d8cd11f55c78f10a548b0/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PriorityQueue.java\">org.apache.hadoop.util.PriorityQueue</a> with its <code class=\"language-text\">adjustTop</code> method (which I believe originated in Apache Lucene).</p>\n<hr>\n<p>If you were to run this algorithm, starting with vertex <code class=\"language-text\">2</code> in red:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9c6829312f66de4046f623544aad4335/e9beb/adjacency_search.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.34177215189873%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4klEQVR42j2P7UtTARTG7+egv6C+BdV/EARFVEJkUfsmBEF9KCQtYsmqDwbSF4VAoyAqNJQonbOlbYm96HQGbWtbuDnc7rbb7l5qb+61rbV7f91t5IFzOPx4zsN5hBWXRHffS7quTjI2uU66UqY6N4t68ADK3j00DLdIFwtkf+UIJNwMf7jCoKWHV64HZDS2FppnaPEi96wXWA6ZEMbNHvadGWP/uUdcujODXC6RGNCjCgJoXTt8CFGWiEXiLHmN9JtOcM14jPvvL5OMp3j6eYjemSP0Th9lyjGMdgV2VwjTopOmoiLHYmyKIYq2ZaTnz1BrVVRNo6qtCX7Jje27lSYN4nKCYHALT3idL76PLVXHsJCPEJMcZPMVNjb87cNEIYdD7Owts/+GciKGGA1SKpTxerxtFotLbIUC7V1oyBMoq7thbRc/7Tq2c7+xBy3cnddhMJ9l6usImXSGXDqPK2xj0NqD3nyakXfXNW2BJf9rDG/PM6BpF3zjCPXIKMon7dEVgYZPR1RMsvDtBTdMXfQZj/PYdptIJKrxH6xuWtC/6W7zhzY9YjDMrPMJN+dO0W88ybR7tBOZqvZuyYmq1OkEg1RRIpr102jWd2K3KltJIeUC/Plb2+HJQpT4toiiNvkHEELLkWpHXjQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"adjacency_search\"\n        title=\"\"\n        src=\"/static/9c6829312f66de4046f623544aad4335/f058b/adjacency_search.png\"\n        srcset=\"/static/9c6829312f66de4046f623544aad4335/c26ae/adjacency_search.png 158w,\n/static/9c6829312f66de4046f623544aad4335/6bdcf/adjacency_search.png 315w,\n/static/9c6829312f66de4046f623544aad4335/f058b/adjacency_search.png 630w,\n/static/9c6829312f66de4046f623544aad4335/e9beb/adjacency_search.png 730w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>You will visit the vertices in that order:</p>\n<blockquote>\n<p>2, 3, 4, 7, 8, 6, 5 (becomes s), 1 (becomes t)</p>\n</blockquote>\n<p>and the cut weight of 5, as the summation of 2 (coming from vertex 2) plus 3 (coming from vertex 5).<br>\nSo as the result we return <code class=\"language-text\">s=5</code>, <code class=\"language-text\">t=1</code> and the cut-weight as <code class=\"language-text\">5</code>.</p>\n<p>Now let’s go one level higher to tie this into the actual <code class=\"language-text\">MinCut</code> algorithm.</p>\n<h2 id=\"finding-the-mincut\" style=\"position:relative;\"><a href=\"#finding-the-mincut\" aria-label=\"finding the mincut permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Finding the MinCut</h2>\n<p>We can now use the Maximum Adjacency Search to compute the <code class=\"language-text\">MinCut</code>, here again with Java and our Graph interface:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> currentPartition <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> currentBestPartition <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">CutOfThePhase</span> currentBestCut <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">.</span><span class=\"token function\">getNumVertices</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">CutOfThePhase</span> cutOfThePhase <span class=\"token operator\">=</span> <span class=\"token function\">maximumAdjacencySearch</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currentBestCut <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> cutOfThePhase<span class=\"token punctuation\">.</span>weight <span class=\"token operator\">&lt;</span> currentBestCut<span class=\"token punctuation\">.</span>weight<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        currentBestCut <span class=\"token operator\">=</span> cutOfThePhase<span class=\"token punctuation\">;</span>\n        currentBestPartition <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>currentPartition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        currentBestPartition<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>cutOfThePhase<span class=\"token punctuation\">.</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    currentPartition<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>cutOfThePhase<span class=\"token punctuation\">.</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// merge s and t and their edges together</span>\n    g <span class=\"token operator\">=</span> <span class=\"token function\">mergeVerticesFromCut</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> cutOfThePhase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// currentBestPartition now contains our first partition.</span></code></pre></div>\n<p>Similar to the pseudo-code, we try to find the best <code class=\"language-text\">cut of the phase</code> and merge the graph until we converge on a single merged vertex.</p>\n<p>As you can see, <code class=\"language-text\">mergeVerticesFromCut</code> is not defined and I leave it up to you to implement as homework. I want to leave a couple of pictures from the paper however as they explain pretty well what needs to be done. Let’s take the output from the Maximum Adjacency Search above:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9c6829312f66de4046f623544aad4335/e9beb/adjacency_search.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.34177215189873%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4klEQVR42j2P7UtTARTG7+egv6C+BdV/EARFVEJkUfsmBEF9KCQtYsmqDwbSF4VAoyAqNJQonbOlbYm96HQGbWtbuDnc7rbb7l5qb+61rbV7f91t5IFzOPx4zsN5hBWXRHffS7quTjI2uU66UqY6N4t68ADK3j00DLdIFwtkf+UIJNwMf7jCoKWHV64HZDS2FppnaPEi96wXWA6ZEMbNHvadGWP/uUdcujODXC6RGNCjCgJoXTt8CFGWiEXiLHmN9JtOcM14jPvvL5OMp3j6eYjemSP0Th9lyjGMdgV2VwjTopOmoiLHYmyKIYq2ZaTnz1BrVVRNo6qtCX7Jje27lSYN4nKCYHALT3idL76PLVXHsJCPEJMcZPMVNjb87cNEIYdD7Owts/+GciKGGA1SKpTxerxtFotLbIUC7V1oyBMoq7thbRc/7Tq2c7+xBy3cnddhMJ9l6usImXSGXDqPK2xj0NqD3nyakXfXNW2BJf9rDG/PM6BpF3zjCPXIKMon7dEVgYZPR1RMsvDtBTdMXfQZj/PYdptIJKrxH6xuWtC/6W7zhzY9YjDMrPMJN+dO0W88ybR7tBOZqvZuyYmq1OkEg1RRIpr102jWd2K3KltJIeUC/Plb2+HJQpT4toiiNvkHEELLkWpHXjQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"adjacency_search\"\n        title=\"\"\n        src=\"/static/9c6829312f66de4046f623544aad4335/f058b/adjacency_search.png\"\n        srcset=\"/static/9c6829312f66de4046f623544aad4335/c26ae/adjacency_search.png 158w,\n/static/9c6829312f66de4046f623544aad4335/6bdcf/adjacency_search.png 315w,\n/static/9c6829312f66de4046f623544aad4335/f058b/adjacency_search.png 630w,\n/static/9c6829312f66de4046f623544aad4335/e9beb/adjacency_search.png 730w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Now the algorithm states, we have to merge <code class=\"language-text\">t</code> into <code class=\"language-text\">s</code>. The result looks like this:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ab5627bccebdff14b54091e686c198cd/f8067/merge_easy.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.810126582278485%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAByklEQVR42lWR22sTURjE8+d4F/8FwReFPiiC9CJF9EEEi1DU+qKlKFbx8mBRjIWYWGkxxSoEW0S0aWNIQK2SZDe7ya7SJprY3HZtkr1kf27WVvTAMDBzmG/Od3z8exzHIzufw7owjHnuLB0hjd3VTBu9XSOSCjD94S7Kego6UKgrzK5M8PzzA37qRXz/Bdo23UhrcADH51ou9AP7SeUk5IxCMHqTvtBOBqf2MTJ3hHxW5cbCGfpDuxgI7WHy/agb2G3luKMc22OtbSCFZ2j2HqXWcwhr6R3Njo3ZMihpq0wlbjHx5hJCOcmG1uJ18iWTsTH8i6MUGvk/DZ3Np1ZrdZaXYximSaPRIJUR2PK37vwollBVFdOwiMfjLptUKhUkUfZ8H1oSxBM44knklTCGAWVNJRQfx//2MqtV8e9Gqs0STxN38EevsJCc9RoW9TyB2DUeLY5tNvx4EF75POiJHiS5wO35IXofb+f4k71cjZwiK2aRBYVAdJxjwW30B3dzce4wivSN65HT9AV3eNr9pRE3cCMNuWFQzmP/Emi3HL7Xv3q/Fv50j7VaHtvqYLi71VpV5jMhnrm6sp7GbNsU6yovvjx04aesr/EbdiDWzbe2RUMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"merge_easy\"\n        title=\"\"\n        src=\"/static/ab5627bccebdff14b54091e686c198cd/f058b/merge_easy.png\"\n        srcset=\"/static/ab5627bccebdff14b54091e686c198cd/c26ae/merge_easy.png 158w,\n/static/ab5627bccebdff14b54091e686c198cd/6bdcf/merge_easy.png 315w,\n/static/ab5627bccebdff14b54091e686c198cd/f058b/merge_easy.png 630w,\n/static/ab5627bccebdff14b54091e686c198cd/f8067/merge_easy.png 726w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>We have one edge in common between <code class=\"language-text\">s</code> and <code class=\"language-text\">t</code>, that is (5,2) and that will inherit the summation of weights (2+2=4). The edge between <code class=\"language-text\">s</code> and <code class=\"language-text\">t</code> is dropped.</p>\n<p>The other case is when an edge has to be transferred (as there is no other to sum it with), below to images illustrate this behaviour:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 564px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/478c19a5104b6b6cafec61cdade6e065/ba4d9/merge_mas_transfer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.93670886075949%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACRUlEQVR42jWS3UtTcRjHz7W9/AFB10V3UV1EQVpWGlF0l90lhJFSiCV0kUJQXVQTGliY2Itp4qwcmkXLFzLddiYuzzTn28ayvahz47hJNs85n347J3/w4/vw+z3Pl+/zfR4JceaWJ+iZbMEV7CCZjYEBOU1DV9Pkmp6Su11L7oMDXdvMf6EJNE8uAYs2WLgFSSf5Qmky5uZaZyFVnSeo6DhC/ccy/AEffiXARulJkCSMggITU7U1KOEQssdLaD5IanA/hkuCoW2Qx99PkGaWxql+V0JN9xlBfIx7n8v5FQuzqqqkS4ox8oQ7d5iE6t06omsq8WiMRDxKZrQQY0AQDW+HfoHxFqS88vhamBeuRwwG35PZSGPoBguRCH6fTOZlM+HKq+Rcn9AN3WpVtGaYmEWdbSTqqRahx3yTtpKGv42QzWbNWJZlPG63GatCqcc3ZiYbIte6Brpu1YVCERRFMWNd+G4pzIR5NWBjeN7JuPBvZnrW8lzbYDTYS+vXh2Jw4yaZqc/4r+/PJm09Xh4860WZS1hDsTwsNT2s6jrOne5LxJYXSa2mef69nkpHETedZ6kUg+ubaCWVVFlaThBPLFF1v5d9Fxo5UNbE3vN2nINBpICYckXHUVFQxJW3h6nru4jsd+OTx7D1X6e87RA3uk5zuf0gb0YamFKm8Xo9TP2cpqy2k92nGthzzs6u4se09ylWy/MrYg8DzXwJtpNct/ZQ29TI/lUZmHXg8NuRIy403dq/Lf9W0uu09vzA9nqUIV/YfPsHIYlO5C2mVj4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"merge_mas_transfer\"\n        title=\"\"\n        src=\"/static/478c19a5104b6b6cafec61cdade6e065/ba4d9/merge_mas_transfer.png\"\n        srcset=\"/static/478c19a5104b6b6cafec61cdade6e065/c26ae/merge_mas_transfer.png 158w,\n/static/478c19a5104b6b6cafec61cdade6e065/6bdcf/merge_mas_transfer.png 315w,\n/static/478c19a5104b6b6cafec61cdade6e065/ba4d9/merge_mas_transfer.png 564w\"\n        sizes=\"(max-width: 564px) 100vw, 564px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Here we have to merge 3 into 7, that means that the edge (3,2) need to be transferred to the former vertex 7:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 547px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7784dfccb4a827673942339bc703f27d/977f7/merge_mas_transfer_result.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.202531645569614%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACKklEQVR42nWSW0iTcRjGv7oKu6igq+6CbroJjPAiXVdd1DLoqi6iE9JhN2FZESHUqBCho0hGZmlaTfOwJqNUNg+t6damxHQecmv5KbpyuM3DDt/h1/YpdJMvvP8/vM/L8z7vyyOE4yL17nKedBdTO3CfufgvpKREEhWpw0q68BCSLp/0rRvI8ShaqCrrhfDIfplTdXsoaTvC2YZcjJbTOPrduNrNKNu3ZToE1C1btV+6dweNSpbXJ7SPf+CauZDr5qNcbdPzabhOA5ZjC8weyIeNG2BzDos5m5huWMWkZEb/OiqF7CNGAjTZapiKTGrFWDSK0+UmNCOy3GdjsOwuyVkRt8/HoNdLOBzWCJVMysq/1AizgJSScTqdSJJEIpHAarUiiqLWEI/H+PK1f22+qtV7ursJBIP/VSmspJdw/LRQ8fkmnf739Dl7iC7ENDC8KNLqqaKqs5TvM30ZFau3UxSF8bFReh1uqluHuP3MTnPXCKm0jFDTb+RM/V5KPuo593YfDzuKCf4I4fW5KG0/zgXTfkrMeore5dEy8IKx4Ql8wz4mJwPoDa/YqX9K7onn7Dj4gPLXDgST9zEXTQVcaTnMpcYC3rjKEEMzTAT9lHUVYTDpNMzQqMM20syfuUhm3QDz8/OcN1rYfaySvJPV7CqsoKrpG4KkpBma7sU6Uotnyk5aTmkrZf2xsPKbrAssvpeMznnWLKiu4tn7LqVotfmpNLno9YQydZW/krxWZPCfhegAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"merge_mas_transfer\"\n        title=\"\"\n        src=\"/static/7784dfccb4a827673942339bc703f27d/977f7/merge_mas_transfer_result.png\"\n        srcset=\"/static/7784dfccb4a827673942339bc703f27d/c26ae/merge_mas_transfer_result.png 158w,\n/static/7784dfccb4a827673942339bc703f27d/6bdcf/merge_mas_transfer_result.png 315w,\n/static/7784dfccb4a827673942339bc703f27d/977f7/merge_mas_transfer_result.png 547w\"\n        sizes=\"(max-width: 547px) 100vw, 547px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Again the edge between <code class=\"language-text\">s</code> and <code class=\"language-text\">t</code> is dropped.<br>\nThat is everything you need to pay attention to when implementing such merge.</p>\n<h2 id=\"reconstructing-the-graphs\" style=\"position:relative;\"><a href=\"#reconstructing-the-graphs\" aria-label=\"reconstructing the graphs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reconstructing the graphs</h2>\n<p>If you followed the above implementation closely, the set of vertex identifiers in our first partition is not really an interesting result. Ideally the result should be two new disjoint graphs (the partitions) and the actual edges that were on the cut of the graph, including their weight.</p>\n<p>Given the original graph, the best cut of the phase and the first partition, we can construct a meaningful result in not-quite-Java:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MinCutResult</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Graph</span> first<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Graph</span> second<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Edge</span><span class=\"token punctuation\">></span></span> edgesOnTheCut<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">MinCutResult</span> <span class=\"token function\">constructMinCutResult</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Graph</span> originalGraph<span class=\"token punctuation\">,</span>\n                                <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> partition<span class=\"token punctuation\">,</span>\n                                <span class=\"token class-name\">CutOfThePhase</span> bestCut<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token class-name\">Graph</span> first <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Graph</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Graph</span> second <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Graph</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Edge</span><span class=\"token punctuation\">></span></span> cuttingEdges <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cutWeight <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> v <span class=\"token operator\">:</span> originalGraph<span class=\"token punctuation\">.</span><span class=\"token function\">getVertexIDSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>partition<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            first<span class=\"token punctuation\">.</span><span class=\"token function\">addVertex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Vertex</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            second<span class=\"token punctuation\">.</span><span class=\"token function\">addVertex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Vertex</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>    \n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Edge</span> e <span class=\"token operator\">:</span> originalGraph<span class=\"token punctuation\">.</span><span class=\"token function\">getEdges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> first<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>destination<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            first<span class=\"token punctuation\">.</span><span class=\"token function\">addEdge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Edge</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span>destination e<span class=\"token punctuation\">.</span>weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> second<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>destination<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            second<span class=\"token punctuation\">.</span><span class=\"token function\">addEdge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Edge</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span>destination<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span>weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            cuttingEdges<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Edge</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span>destination<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span>weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            cutWeight <span class=\"token operator\">+=</span> weight<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MinCut</span><span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">,</span> cuttingEdges<span class=\"token punctuation\">,</span> cutWeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>It works in two steps:</p>\n<ol>\n<li>iterating over the set of vertices in the original graph: partition into the two subgraphs by checking what vertices our algorithm assigned to the first partition. If a vertex is not part of that partition, it must be in the second subgraph.</li>\n<li>iterating over the set of edges in the original graph: if both source and destination vertex are both in a graph, add it to the respective graph. Otherwise it must be an edge on the cut.</li>\n</ol>\n<p>And that’s it!</p>\n<h2 id=\"full-code\" style=\"position:relative;\"><a href=\"#full-code\" aria-label=\"full code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Full Code</h2>\n<p>As already stated in the beginning, the full implementation of the <a href=\"https://github.com/thomasjungblut/tjungblut-graph/blob/master/src/de/jungblut/graph/partition/StoerWagnerMinCut.java\">Stoer-Wagner algorithm</a> can be found in my <a href=\"https://github.com/thomasjungblut/tjungblut-graph\">graph library</a>.</p>\n<p>Don’t be scared by the generics, it’s fairly simple if you can just drag it back into strings and integers. As always, a good start are <a href=\"https://github.com/thomasjungblut/tjungblut-graph/blob/master/test/de/jungblut/graph/partition/StoerWagnerMinCutTest.java\">the test cases</a>. Otherwise feel free to reach out to me, I’m happy to help if you have any questions.</p>","frontmatter":{"title":"Minimum Cut - Stoer–Wagner algorithm","date":"18th October 2020","description":null},"tableOfContents":"<ul>\n<li><a href=\"#what-are-minimum-cuts\">What are Minimum Cuts?</a></li>\n<li><a href=\"#what-are-some-real-life-applications-for-it\">What are some real-life applications for it?</a></li>\n<li><a href=\"#the-intuition-of-the-algorithm\">The intuition of the algorithm</a></li>\n<li><a href=\"#the-formal-algorithm\">The formal algorithm</a></li>\n<li><a href=\"#maximum-adjacency-search\">Maximum Adjacency Search</a></li>\n<li><a href=\"#finding-the-mincut\">Finding the MinCut</a></li>\n<li><a href=\"#reconstructing-the-graphs\">Reconstructing the graphs</a></li>\n<li><a href=\"#full-code\">Full Code</a></li>\n</ul>","timeToRead":9},"previous":{"fields":{"slug":"/random/2020-blogging/"},"frontmatter":{"title":"Back to Blogging - 2020 Edition"}},"next":{"fields":{"slug":"/random/virtualbox-hyperv-vagrant/"},"frontmatter":{"title":"VirtualBox, Vagrant, WSL2 and Docker on Windows 10"}}},"pageContext":{"id":"f2920e83-517d-5f8d-8b3a-b66adb1c3a78","previousPostId":"ca1066e6-4031-57ec-b2a4-48e9b069af25","nextPostId":"f4e6cc4f-8a7a-5f46-b3dc-dc1665110c18"}},"staticQueryHashes":["2270107033","2841359383"],"slicesMap":{}}